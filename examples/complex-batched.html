<!DOCTYPE html><html>
<head>
  <meta charset=utf-8 />
  <title>JS Bin</title>
  <style id="jsbin-css">
  * {
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  margin: 0;
  padding 0;
}

.buttons {
  position: absolute;
}

.module {
  height: 200px;
  border: solid 2px red;
  background: red;
  margin: 10px;
}

.module div {
  border: solid 2px red;
  background: white;
}


</style>
</head>
<body>
  <div class="buttons"><button id="sencha">Sencha</button> <button id="performant">Performant</button> <button id="crappy">Crappy</button></div><div class="module module-a"><div></div><div></div></div><div class="module module-b"><div></div><div></div><div></div></div><div class="module module-c"><div></div><div></div><div></div><div></div></div>
<script type="text/javascript" src="../lib/dom-batch.js"></script>
<script>
/*jshint laxbreak:true*/

/**
 * @private
 * Handle batch read / write of DOMs, currently used in SizeMonitor + PaintMonitor
 */

    var pending = false,
        mode = true;

    function TaskQueue() {
        this.readQueue = [];
        this.writeQueue = [];

        this.run = this.run.bind(this);
    }

    TaskQueue.prototype.requestRead = function(fn, scope, args) {
        this.request(true);
        this.readQueue.push(arguments);
    };

    TaskQueue.prototype.requestWrite = function(fn, scope, args) {
        this.request(false);
        this.writeQueue.push(arguments);
    };

    TaskQueue.prototype.request = function(mode) {
        if (!this.pending) {
            this.pending = true;
            this.mode = mode;
            if (mode) {
                setTimeout(this.run, 1);
            } else {
                requestAnimationFrame(this.run);
            }
        }
    };

    TaskQueue.prototype.run = function() {
        this.pending = false;

        var readQueue = this.readQueue,
            writeQueue = this.writeQueue,
            request = null,
            queue;

        if (this.mode) {
            queue = readQueue;

            if (writeQueue.length > 0) {
                request = false;
            }
        }
        else {
            queue = writeQueue;

            if (readQueue.length > 0) {
                request = true;
            }
        }

        var tasks = queue.slice(),
            i, ln, task, fn, scope;

        queue.length = 0;

        for (i = 0, ln = tasks.length; i < ln; i++) {
            task = tasks[i];
            fn = task[0];
            scope = task[1];

            if (typeof fn == 'string') {
                fn = scope[fn];
            }

            if (task.length > 2) {
                fn.apply(scope, task[2]);
            }
            else {
                fn.call(scope);
            }
        }

        tasks.length = 0;

        if (request !== null) {
            this.request(request);
        }
    };



var perform;
var frameCount = 0;

var tq = new TaskQueue();




var dom = new DomBatch();






function moduleA(cb) {
  var el = document.querySelector('.module-a');

  // Write
  setChildHeights(el, function() {
    printChildHeights(el, cb.bind(null, 'a'));
  });
}


function moduleB(cb) {
  var el = document.querySelector('.module-b');


  setChildHeights(el, function() {
    printChildHeights(el, cb.bind(null, 'b'));
  });
}


function moduleC(cb) {
  var el = document.querySelector('.module-c');

  setChildHeights(el, function() {
    printChildHeights(el, cb.bind(null, 'c'));
  });
}

function getRandomLength() {
  return Math.floor(Math.random() * 100) * (Math.random() < 0.5 ? 1 : -1);
}


function setChildHeights(el, cb) {
  var c = el.children;
  var n = c.length;

  console.log("Requesting write: setChildHeights initial");
  dom.write(function setModuleHeights() {
    el.style.height = (200 + getRandomLength()) + 'px';
    console.log("DOM WRITE: setChildHeights initial");

      console.log("Requesting read: setChildHeights");
      dom.read(function() {
        var h = el.clientHeight / n;
        console.log("DOM READ: setChildHeights");

        console.log("Requesting write: setChildHeights");
        dom.write(function() {
          while (n--) {
            c[n].style.height = h + 'px';
          }
          console.log("DOM WRITE: setChildHeights");

          cb();
        });
      });
  });
}

function printChildHeights(el, cb) {
  var c = el.children;
  var n = c.length;

  console.log("Requesting read: printChildHeights");
  dom.read(function() {
    var h = c[0].clientHeight;
    console.log("DOM READ: printChildHeights");

    console.log("Requesting write: printChildHeights");
    dom.write(function() {
      while (n--) {
        c[n].innerHTML = 'My height is: ' + h + 'px';
      }
      console.log("DOM WRITE: printChildHeights");
      cb();
    });
  });
}

function go(type, cb) {
  console.log('starting ' + type);
  cb = cb || function() {};
  moduleA(cb);
  moduleB(cb);
  moduleC(cb);
}

performant.onclick = function() {

  perform = 'performant';

  var start = performance.now();
  var done = [];
  go('performant', function(module) {
    console.log('performant completed ' + module);
    done.push(module);
    if (done.length === 3) {
      console.log('Performant took ' + (performance.now() - start));
    }
  });

};

sencha.onclick = function() {

  perform = 'sencha';

  var start = performance.now();
  var done = [];
  go('sencha', function(module) {
    done.push(module);
    if (done.length === 3) {
      console.log('Sencha took ' + (performance.now() - start));
    }
  });

};
crappy.onclick = function() {

  perform = 'crappy';

  var start = performance.now();
  go('crappy');
  console.log('Crappy took ' + (performance.now() - start));
};
</script>
</body>
</html>